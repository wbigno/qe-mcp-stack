/**
 * Unit Test Generator
 * 
 * Core logic for generating xUnit unit tests for .NET C# classes
 */

import { readFileSync, existsSync } from 'fs';
import { join } from 'path';
import { generateWithClaude } from './claudeClient.js';

/**
 * Generate unit tests for a C# class
 * 
 * @param {Object} params - Generation parameters
 * @returns {Promise<Object>} Generated tests with metadata
 */
export async function generateUnitTests(params) {
  const {
    app,
    className,
    methodName,
    sourceCode,
    includeNegativeTests = true,
    includeMocks = true,
    onlyNegativeTests = false,
    testFramework = 'xUnit' // Default to xUnit for backwards compatibility
  } = params;

  // Validate input
  validateInput(params);

  // Get source code (from parameter or file)
  const code = sourceCode || loadSourceCode(app, className);

  // Generate tests with Claude
  const generated = await generateWithClaude({
    className,
    methodName,
    sourceCode: code,
    includeNegativeTests,
    includeMocks,
    onlyNegativeTests,
    testFramework
  });

  // Assemble complete test file
  const completeTestFile = assembleTestFile(generated, testFramework);

  // Calculate statistics
  const stats = calculateStatistics(generated);

  return {
    tests: generated.tests,
    mocks: generated.mocks,
    testFixture: generated.testFixture,
    completeTestFile,
    statistics: stats,
    metadata: {
      app,
      className,
      methodName: methodName || 'all',
      generatedAt: new Date().toISOString(),
      version: '1.0.0',
      includeNegativeTests,
      includeMocks,
      onlyNegativeTests
    }
  };
}

/**
 * Validate input parameters
 */
function validateInput(params) {
  const { app, className, sourceCode } = params;

  if (!app || typeof app !== 'string') {
    throw new Error('app must be a string');
  }

  if (!className || typeof className !== 'string') {
    throw new Error('className must be a string');
  }

  // If source code not provided, we'll need to load it from file
  if (!sourceCode) {
    // This is OK - we'll load from file
  } else if (typeof sourceCode !== 'string') {
    throw new Error('sourceCode must be a string');
  }
}

/**
 * Load source code from file system
 */
function loadSourceCode(app, className) {
  // Try to find the source file
  const possiblePaths = [
    `/mnt/apps/${app}/Services/${className}.cs`,
    `/mnt/apps/${app}/Controllers/${className}.cs`,
    `/mnt/apps/${app}/Models/${className}.cs`,
    `/mnt/apps/${app}/${className}.cs`
  ];

  for (const path of possiblePaths) {
    if (existsSync(path)) {
      return readFileSync(path, 'utf8');
    }
  }

  // If we can't find the file, throw a helpful error
  throw new Error(
    `Could not find source file for ${className}. ` +
    `Tried: ${possiblePaths.join(', ')}. ` +
    `Please provide sourceCode in the input or ensure the file exists.`
  );
}

/**
 * Get default namespaces based on test framework
 */
function getDefaultNamespaces(testFramework) {
  switch (testFramework.toLowerCase()) {
    case 'xunit':
      return 'using Xunit;\nusing Moq;\nusing System;\n\n';
    case 'mstest':
      return 'using Microsoft.VisualStudio.TestTools.UnitTesting;\nusing Moq;\nusing System;\n\n';
    case 'nunit':
      return 'using NUnit.Framework;\nusing Moq;\nusing System;\n\n';
    default:
      // Default to xUnit for backwards compatibility
      return 'using Xunit;\nusing Moq;\nusing System;\n\n';
  }
}

/**
 * Assemble complete test file from generated components
 */
function assembleTestFile(generated, testFramework) {
  const { tests, mocks, testFixture } = generated;
  const { className, namespaces, setupCode } = testFixture;

  let fileContent = '';

  // Add using statements
  fileContent += '// Generated Unit Tests\n';
  fileContent += '// Generated by QE MCP Stack - Unit Test Generator\n\n';

  if (namespaces && namespaces.length > 0) {
    fileContent += namespaces.join('\n') + '\n\n';
  } else {
    // Default namespaces based on test framework
    fileContent += getDefaultNamespaces(testFramework);
  }

  // Add test class
  fileContent += `namespace UnitTests\n`;
  fileContent += `{\n`;
  fileContent += `    public class ${className}\n`;
  fileContent += `    {\n`;

  // Add setup code if present
  if (setupCode && setupCode.trim()) {
    fileContent += `        ${setupCode.split('\n').join('\n        ')}\n\n`;
  }

  // Add mock setup methods if present
  if (mocks && mocks.length > 0) {
    fileContent += `        // Mock Setup Methods\n\n`;
    mocks.forEach(mock => {
      if (mock.mockCode) {
        fileContent += `        ${mock.mockCode.split('\n').join('\n        ')}\n\n`;
      }
    });
  }

  // Add test methods
  fileContent += `        // Test Methods\n\n`;
  tests.forEach((test, index) => {
    if (index > 0) fileContent += '\n';
    
    // Add test description as comment
    fileContent += `        /// <summary>\n`;
    fileContent += `        /// ${test.description}\n`;
    fileContent += `        /// </summary>\n`;
    
    // Add test code (with proper indentation)
    const testCodeLines = test.testCode.split('\n');
    testCodeLines.forEach(line => {
      fileContent += `        ${line}\n`;
    });
  });

  // Close class and namespace
  fileContent += `    }\n`;
  fileContent += `}\n`;

  return fileContent;
}

/**
 * Calculate test statistics
 */
function calculateStatistics(generated) {
  const { tests, mocks } = generated;

  const totalTests = tests.length;
  const positiveTests = tests.filter(t => t.category === 'positive').length;
  const negativeTests = tests.filter(t => t.category === 'negative').length;
  const edgeCaseTests = tests.filter(t => t.category === 'edge-case').length;

  // Count unique assertions used
  const allAssertions = tests.flatMap(t => t.assertions || []);
  const uniqueAssertions = [...new Set(allAssertions)];

  // Count dependencies
  const allDependencies = tests.flatMap(t => t.dependencies || []);
  const uniqueDependencies = [...new Set(allDependencies)];

  return {
    totalTests,
    byCategory: {
      positive: positiveTests,
      negative: negativeTests,
      edgeCase: edgeCaseTests
    },
    assertions: {
      total: allAssertions.length,
      unique: uniqueAssertions.length,
      types: uniqueAssertions
    },
    dependencies: {
      total: uniqueDependencies.length,
      list: uniqueDependencies
    },
    mocks: {
      total: mocks.length,
      interfaces: mocks.map(m => m.interfaceName)
    }
  };
}

export default {
  generateUnitTests
};
