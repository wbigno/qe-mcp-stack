/**
 * Integration Test Generator
 * 
 * Core logic for generating integration tests for APIs and services
 */

import { generateWithClaude } from './claudeClient.js';

/**
 * Generate integration tests for API endpoint
 * 
 * @param {Object} params - Generation parameters
 * @returns {Promise<Object>} Generated tests with metadata
 */
export async function generateIntegrationTests(params) {
  const {
    app,
    apiEndpoint,
    scenario,
    includeAuth = true,
    includeDatabase = true
  } = params;

  // Validate input
  validateInput(params);

  // Generate tests with Claude
  const generated = await generateWithClaude({
    apiEndpoint,
    scenario,
    includeAuth,
    includeDatabase
  });

  // Assemble complete test file
  const completeTestFile = assembleTestFile(generated, apiEndpoint);

  // Generate additional test helpers
  const helpers = generateTestHelpers(apiEndpoint, includeAuth, includeDatabase);

  // Calculate statistics
  const stats = calculateStatistics(generated);

  return {
    tests: generated.tests,
    setupCode: generated.setupCode,
    teardownCode: generated.teardownCode,
    testDataSeed: generated.testDataSeed,
    testFixture: generated.testFixture,
    helpers,
    completeTestFile,
    statistics: stats,
    metadata: {
      app,
      apiEndpoint,
      scenario: scenario || 'Full CRUD operations',
      generatedAt: new Date().toISOString(),
      version: '1.0.0',
      includeAuth,
      includeDatabase
    }
  };
}

/**
 * Validate input parameters
 */
function validateInput(params) {
  const { app, apiEndpoint } = params;

  if (!app || typeof app !== 'string') {
    throw new Error('app must be a string');
  }

  if (!apiEndpoint || typeof apiEndpoint !== 'string') {
    throw new Error('apiEndpoint must be a string');
  }

  if (!apiEndpoint.startsWith('/')) {
    throw new Error('apiEndpoint must start with /');
  }
}

/**
 * Assemble complete test file from generated components
 */
function assembleTestFile(generated, apiEndpoint) {
  const { tests, setupCode, teardownCode, testDataSeed, testFixture } = generated;
  const { className, namespaces, baseClass } = testFixture;

  let fileContent = '';

  // Add header
  fileContent += '// Generated Integration Tests\n';
  fileContent += '// Generated by QE MCP Stack - Integration Test Generator\n';
  fileContent += `// Endpoint: ${apiEndpoint}\n\n`;

  // Add using statements
  if (namespaces && namespaces.length > 0) {
    fileContent += namespaces.join('\n') + '\n\n';
  } else {
    // Default namespaces
    fileContent += 'using Xunit;\n';
    fileContent += 'using Microsoft.AspNetCore.Mvc.Testing;\n';
    fileContent += 'using System.Net.Http.Json;\n';
    fileContent += 'using System.Net;\n';
    fileContent += 'using System.Threading.Tasks;\n\n';
  }

  // Add test class
  fileContent += `namespace IntegrationTests\n`;
  fileContent += `{\n`;
  
  // Add class with fixture if specified
  if (baseClass) {
    fileContent += `    public class ${className} : ${baseClass}\n`;
  } else {
    fileContent += `    public class ${className}\n`;
  }
  
  fileContent += `    {\n`;

  // Add setup code
  if (setupCode && setupCode.trim()) {
    fileContent += `        ${setupCode.split('\n').join('\n        ')}\n\n`;
  }

  // Add test data seeding methods
  if (testDataSeed && testDataSeed.seedMethods && testDataSeed.seedMethods.length > 0) {
    fileContent += `        // Test Data Seeding\n\n`;
    testDataSeed.seedMethods.forEach(seedMethod => {
      fileContent += `        ${seedMethod.split('\n').join('\n        ')}\n\n`;
    });
  }

  // Add test methods
  fileContent += `        // Integration Tests\n\n`;
  tests.forEach((test, index) => {
    if (index > 0) fileContent += '\n';
    
    // Add test description as comment
    fileContent += `        /// <summary>\n`;
    fileContent += `        /// ${test.description}\n`;
    fileContent += `        /// Method: ${test.httpMethod} ${test.endpoint}\n`;
    fileContent += `        /// Expected: ${test.statusCode}\n`;
    fileContent += `        /// </summary>\n`;
    
    // Add test code (with proper indentation)
    const testCodeLines = test.testCode.split('\n');
    testCodeLines.forEach(line => {
      fileContent += `        ${line}\n`;
    });
  });

  // Add teardown if present
  if (teardownCode && teardownCode.trim()) {
    fileContent += `\n        ${teardownCode.split('\n').join('\n        ')}\n`;
  }

  // Close class and namespace
  fileContent += `    }\n`;
  fileContent += `}\n`;

  return fileContent;
}

/**
 * Generate helper methods and utilities
 */
function generateTestHelpers(apiEndpoint, includeAuth, includeDatabase) {
  const helpers = {
    httpClientHelper: generateHttpClientHelper(),
    testDataHelper: null,
    authHelper: null
  };

  if (includeDatabase) {
    helpers.testDataHelper = generateTestDataHelper();
  }

  if (includeAuth) {
    helpers.authHelper = generateAuthHelper();
  }

  return helpers;
}

/**
 * Generate HTTP client helper code
 */
function generateHttpClientHelper() {
  return `// HTTP Client Helper Methods

private HttpClient CreateAuthenticatedClient(string token)
{
    var client = _factory.CreateClient();
    client.DefaultRequestHeaders.Authorization = 
        new System.Net.Http.Headers.AuthenticationHeaderValue("Bearer", token);
    return client;
}

private async Task<T> GetAsync<T>(string endpoint)
{
    var client = _factory.CreateClient();
    var response = await client.GetAsync(endpoint);
    response.EnsureSuccessStatusCode();
    return await response.Content.ReadFromJsonAsync<T>();
}

private async Task<HttpResponseMessage> PostAsync<T>(string endpoint, T data)
{
    var client = _factory.CreateClient();
    return await client.PostAsJsonAsync(endpoint, data);
}`;
}

/**
 * Generate test data helper code
 */
function generateTestDataHelper() {
  return `// Test Data Helper Methods

private async Task SeedTestData()
{
    // Seed your test database here
    // Example:
    // await _context.Users.AddAsync(new User { Name = "Test User" });
    // await _context.SaveChangesAsync();
}

private async Task CleanupTestData()
{
    // Clean up test data after each test
    // Example:
    // _context.Users.RemoveRange(_context.Users);
    // await _context.SaveChangesAsync();
}`;
}

/**
 * Generate authentication helper code
 */
function generateAuthHelper() {
  return `// Authentication Helper Methods

private string GenerateValidToken()
{
    // Generate a valid JWT token for testing
    // This should match your app's token generation logic
    return "valid_test_token";
}

private string GenerateExpiredToken()
{
    // Generate an expired JWT token for testing
    return "expired_test_token";
}

private HttpClient CreateClientWithAuth(string role = "User")
{
    var token = GenerateValidToken();
    var client = _factory.CreateClient();
    client.DefaultRequestHeaders.Authorization = 
        new System.Net.Http.Headers.AuthenticationHeaderValue("Bearer", token);
    return client;
}`;
}

/**
 * Calculate test statistics
 */
function calculateStatistics(generated) {
  const { tests } = generated;

  const totalTests = tests.length;

  // Count by HTTP method
  const byHttpMethod = tests.reduce((acc, test) => {
    acc[test.httpMethod] = (acc[test.httpMethod] || 0) + 1;
    return acc;
  }, {});

  // Count by status code
  const byStatusCode = tests.reduce((acc, test) => {
    const code = test.statusCode.toString();
    acc[code] = (acc[code] || 0) + 1;
    return acc;
  }, {});

  // Count by category
  const byCategory = tests.reduce((acc, test) => {
    acc[test.category] = (acc[test.category] || 0) + 1;
    return acc;
  }, {});

  // Count auth vs non-auth
  const requiresAuth = tests.filter(t => t.requiresAuth).length;
  const noAuth = totalTests - requiresAuth;

  return {
    totalTests,
    byHttpMethod,
    byStatusCode,
    byCategory,
    authentication: {
      requiresAuth,
      noAuth
    },
    coverage: {
      crud: {
        create: byHttpMethod.POST || 0,
        read: byHttpMethod.GET || 0,
        update: byHttpMethod.PUT || 0,
        delete: byHttpMethod.DELETE || 0
      },
      successCases: Object.keys(byStatusCode).filter(c => c.startsWith('2')).reduce((sum, c) => sum + byStatusCode[c], 0),
      errorCases: Object.keys(byStatusCode).filter(c => !c.startsWith('2')).reduce((sum, c) => sum + byStatusCode[c], 0)
    }
  };
}

export default {
  generateIntegrationTests
};
